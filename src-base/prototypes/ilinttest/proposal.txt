

ILInt:

ILInt is compact representation of un unsigned integer values from 8 to 64 bits.

All integers can be encoded as 1 to 9 bytes depending on the value that must be represented.

The first byte is called the control byte. If its value is between 0 and 247, it will represent
the value itself. Otherwise, the least 3 significant bits represents number of data bytes - 1 and the
bit 3 will represent the signal of the integer.

The data bytes encodes the actual value - 248 encoded as a big endian value.

Examples:

	0 = 0x00
	1 = 0x01
	239 = 0xF7
	248 = 0xF8 0x00
	503 = 0xF8 0xFF
	543 = 0xF9 0x01 0x00

Although this encoding scheme allows the encoding of values in more than one way (using leading zeroes),
the value must be represented using smallest possible way to represent the value.
 
Invalid encodings:
	503 = 0xF9 0x00 0xFF


Tags:

Tags with ids lower than 64 are reserved and holds primitive data. They do not have the lenght field.

The format of those tags are:
	TagID: ILInt
	Value: byte[]

0: NULL - No payload
1: True - No payload
2: False - No payload
3: String - ILInt length
	characters (utf8) 
4: List - ILInt Number of entries
	Tags
5: Dictionary:
	ILInt Number of entries
	Tags
16: int8 - 1 byte
17: uint8 - 1 byte
18: int16 - 2 bytes
19: uint16 - 2 bytes
20: int32 - 4 bytes
21: uint32 - 4 bytes
22: int64 - 8 bytes
23: uint64 - 8 bytes




Tags with ids higher than 63 are defined by the application.

	TagId: ILInt
	TagSize: ILInt
	Data: byte[TagSize]



blockID: uint64
payloadSize: uint32
	payload: byte[payloadSize]
pubSize: uint16
	pubdata: byte[pubSize]
signatureSize: uin16

ASN.1 DER vs BSON vs Custom


PackedInteger:
	control:
		
	rest:
	


